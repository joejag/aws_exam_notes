# Applications

## SQS

- Oldest service. Webservice gives access to a message queue
- The queue is temporary while they await processing
- decouples components with a fail-safe queue
- upto 256k text in queue, upto 2Gb in S3 if you go over
- consumeres can be inttermitedtly connected to the network
- Two types:
  - Standard Queues
    - Nearly unlimited per second, at-least-once delivery. Order not guaranteed, best efforts
  - FIFO Queues
    - order and once delivery
    - 300 per second max
    - message groups
- Summary:
  - Pull based
  - 256k size
  - Messages kept for 1m-14 days. Default is 4 days
  - Visibility timeout: how long does the message disappear from when it is picked up
    - could cause double processing if timeout is too low
    - max 12 hours for timeout
  - guaranteed at least once processing
  - SQS Long Polling: Doesn't return anything until a message appears of a timeout. Default can get empty
    - reduces charges since you aren't generating as much traffic

## Simple Workflow Service (SWF)

- coordinates work across a bunch of components
- task based - code with manual human steps
- Amazon use this inside their warehouse when picking things
- vs SQS
  - Retention: SQS:14d, SWF:365d
  - SWF is task orientated, SQS is message orientated
  - SWF tasks are assigned and never duplciated. SQS you must handle this and not handled twice
  - SWF tracks all tasks in an App. SQS you need to do this yourself if you have multiple queues
- SWF Actors:
  - Workflow Starters (could be app)
  - Deciders (controls flow)
  - Activity Workers

## Simple Notification Service (SNS)

- send notifications immediately to subscribers or other apps
- mobile app push notifications. Also SMS, email, SQS or HTTP endpoints
- Topic: group multiple recipients
- SNS uses multi AZ for redundancy
- Summary:
  - push, immeditate (no polling)
  - Simple/easy
  - Flexible message delivery
  - Cheap, no up front cost
  - Console makes it easy to use
- SNS vs SQS
  - Both messaging. SNS=push, SQS=pull/poll

## Elatic Transcoder

- Media transcoder in the cloud. Convert formats of files so they work on certain devices
- It knows what works well on devices already, no guessing
- Pay on rez and time it takes

## API Gateway

- Makes it easier to publish, monitor and secure APIs at scale
  - Exposts HTTPs endpoints
  - Connect to DynamoDB & Lambda
  - Send each API endpoint to a different target
  - Scales, low cost
  - Track usage by API Key
  - throttle requests to prevent attacks
  - CloudWatch for monitoring
  - Maintain multiple version of your APIs
- Configuring:
  - Define an API/Contrainer
  - Define resources, nested resources in it
    - foreach rez: http verb, security, choose target (lambda), set transformations
- Deploy:
  - Uses stages.
  - API Gateway Domain by default. Can use custom domain
  - Uses AWS Cert Manager for free certs
- API caching:
  - Set TTL to cache responses
- Same Origin Policy:
  - Prevent XSS (browsers do it, postman/curl ignore it)
  - If "Origin policy cannot be read by the remote resource" turn on CORS on API Gateway

## Kinesis

- Streaming Data
  - generated by thousands of data sources, sent at the same time in small sizes
    - eg purchases from a store, stock prices, game data, social network data, iOT sensors
- Kinesis: Platform for sending streaming data to. Loads, analyses, lets you build apps
  - Three types:
    - KDS! Kinesis Streams:
      - Many producer devices stream data (1-7 day retention)
      - Data is in shards
      - Shard data goes to EC2 consumers. Who store results elsewhere
      - Shards
        - 5 transactions a second for reads (2Mb per sec), 1k write (1M per sec)
        - capacity is by how many shards are on the stream
    - Kinesis Firehose:
      - Data analysed as it arrives (could be Lamdda storing to S3, then to Redshift OR just elasticsearch)
    - Kinesis Analytics:
      - Works with streams and FireHouse and analyses on the fly storing it to S3/redshift/ES
- Summary
  - Shards == Streams
  - Data persistence == Streams
  - On the fly analyse == FireHose
  - Analyse inside Kinesis == Analytics

## Web Identity Federation & Cognito

- Users use Google etc to log in to your services which gives them AWS creds
- Cogntio:
  - Sign up and sign in
  - Guest users
  - Does the Identity code. Is this Auth0?
  - Sync user data to multiple devices (username sync)
  - rec for Mobile apps
- Cognito maps to IAM roles. No AWS creds on the device
- User Pools (email, password)
  - Manage signups, can use directly or via Google etc. You get a JWT
- Identity Pools (AWS resources grants)
  - Temp access to S3 or DynamoDb
- Auth flow
  - User -> UserPool -> Google
  - User gets JWT
  - JWT -> IdentityPool
  - User gets AWS creds via IAM role
  - User access resources
- Cognito Sync
  - sends silent SNS when user data changes to their other devices
- Summary
  - federated user auth
  - Cognito is an Identity Broker which handles the ID Provider (no code to write)
  - userpool: users, account recovery. IdentityPool: grants IAM roles

## Event Processing Patterns

- EDA: decoupled. Pub/Sub is immediate (SNS)
  - Pub pushes to SNS topic. All subscribers get the message
- Dead Letter Queue (DLQ): When your retries all failed
  - SNS, sends to SQS on client failure
  - SQS, sends to antoerh SQS queue when maxRecieve is full
  - Lambda, failed async invoke, retry twice then send to SNS or SQS
- FanOut Pattern:
  - Publisher needs to send message to multiple places guaranteed
    - Send to SNS instead, then to SQS queuse in downstream systems
    - Also used to replicate load to test envs from prod
- S3 Event Notifications:
  - When certain things happen in your bucket -> SQS, SNS or Lambda
  - Need versioning to get updates to an object
  - Types:
    - Object created, removed, restored from glacial, RRS lost. Replication failures
- Summary
  - pub/sub is SNS
  - DLQ is SNS, SQS, Lambda
  - Fanout uses SNS
  - S3 event notifications go to SNS, SQS, Lambda

## Scaling EC2 with SQS Lab

- SQS exposts a ApproprixateAmountOfVisibleMessages, which can trigger CloudWatch alarms
- CloudWAtch alarms can trigger AutoScaling groups
- SQS has pre made metrics in CloudWatch
- AutoScaling groups have Policies - choose simple, add capacity with wait before adding more

## Quiz

- SWF groups in 'domains' for similar work. SWF can use HTTP to process tasks
